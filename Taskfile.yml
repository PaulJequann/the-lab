---
version: "3"

vars:
  KUBERNETES_DIR: "{{.ROOT_DIR}}/kubernetes"
  ANSIBLE_DIR: "{{.ROOT_DIR}}/ansible"
  TERRAFORM_DIR: "{{.ROOT_DIR}}/terraform"

dotenv: [".config.env"]

env:
  KUBECONFIG: "{{.ROOT_DIR}}/kubeconfig"
  SOPS_AGE_KEY_FILE: ~/.config/sops/age/keys.txt

includes:
  ansible: .taskfiles/AnsibleTasks.yml
  cluster: .taskfiles/ClusterTasks.yml
  precommit: .taskfiles/PrecommitTasks.yml
  terraform: .taskfiles/TerraformTasks.yml
  secrets: .taskfiles/SecretTasks.yaml

tasks:
  init:
    desc: Initialize workstation dependencies
    cmds:
      - task: detect_os
      - task: install_deps

  detect_os:
    internal: true
    silent: true
    cmds:
      - |
        if command -v pacman &> /dev/null; then
          echo "export PKG_MANAGER=pacman" >> .pkg_manager
        elif command -v brew &> /dev/null; then
          echo "export PKG_MANAGER=brew" >> .pkg_manager
        else
          echo "No supported package manager found. Please install dependencies manually."
          exit 1
        fi

  install_deps:
    internal: true
    deps: [detect_os]
    cmds:
      - |
        source .pkg_manager
        if [ "$PKG_MANAGER" = "pacman" ]; then
          sudo pacman -Syu --needed {{.DEPS}} {{.CLI_ARGS}}
        elif [ "$PKG_MANAGER" = "brew" ]; then
          brew install {{.DEPS}} {{.CLI_ARGS}}
        fi
    vars:
      # macOS dependencies
      # fluxcd/tap/flux
      # go-task/tap/go-task
      # kubernetes-cli
      # weaveworks/tap/gitops
      # add weavework gitops later
      DEPS: >-
        age
        ansible
        direnv
        docker
        fluxcd
        task
        helm
        jq
        kubectl
        kustomize
        pre-commit
        prettier
        python-pip
        sops
        stern
        terraform
        tflint
        yamllint
        yq

  verify:
    desc: Verify env settings
    cmds:
      - ./configure --verify

  # configure:
  #   desc: Configure repository from env settings
  #   cmds:
  #     - ./configure

  configure:
    desc: Configure repository from env settings
    cmds:
      - task: render-templates
      - task: encrypt-secrets
      - task: download-cert-manager-crds
    sources:
      - config.yaml
      - templates/**/*.j2

  render-templates:
    desc: Render templates for Ansible and Terraform
    sources:
      - config.yaml
      - templates/**/*.j2
    generates:
      - "{{.ANSIBLE_DIR}}/**/*"
      - "{{.TERRAFORM_DIR}}/**/*"
      - "{{.KUBERNETES_DIR}}/**/*"
    cmds:
      - echo "Regenerating templates (sources changed)..."
      - makejinja --input ./templates/ansible/ --output {{.ANSIBLE_DIR}}
      - makejinja --input ./templates/terraform/ --output {{.TERRAFORM_DIR}}/
      - makejinja --input ./templates/kubernetes/ --output {{.KUBERNETES_DIR}}
      - echo "Templates regenerated successfully"

  encrypt-secrets:
    cmds:
      - for: { var: SECRET_FILES }
        cmd: |
          # Check if file is currently encrypted
          if sops filestatus "{{.ITEM}}" | jq --exit-status ".encrypted" &>/dev/null; then
            echo "Skipping {{.ITEM}} - already encrypted"
          else
            # File is plaintext - check if we have a backup to compare against
            BACKUP_FILE="{{.ITEM}}.encrypted.bak"
            CHECKSUM_FILE="{{.ITEM}}.checksum"

            if [ -f "$BACKUP_FILE" ] && [ -f "$CHECKSUM_FILE" ]; then
              # Compare checksum of current plaintext with stored checksum
              CURRENT_CHECKSUM=$(sha256sum "{{.ITEM}}" | awk '{print $1}')
              STORED_CHECKSUM=$(cat "$CHECKSUM_FILE")

              if [ "$CURRENT_CHECKSUM" = "$STORED_CHECKSUM" ]; then
                echo "Restoring {{.ITEM}} from backup - content unchanged"
                cp "$BACKUP_FILE" "{{.ITEM}}"
              else
                echo "Encrypting {{.ITEM}} - content changed"
                sops --encrypt --in-place "{{.ITEM}}"
                cp "{{.ITEM}}" "$BACKUP_FILE"
                echo "$CURRENT_CHECKSUM" > "$CHECKSUM_FILE"
              fi
            else
              echo "Encrypting {{.ITEM}} - first time"
              CURRENT_CHECKSUM=$(sha256sum "{{.ITEM}}" | awk '{print $1}')
              sops --encrypt --in-place "{{.ITEM}}"
              cp "{{.ITEM}}" "$BACKUP_FILE"
              echo "$CURRENT_CHECKSUM" > "$CHECKSUM_FILE"
            fi
          fi

  # encrypt-secrets:
  #   cmds:
  #     - for: { var: SECRET_FILES }
  #       cmd: |
  #         if sops filestatus "{{.ITEM}}" | jq --exit-status ".encrypted == false" &>/dev/null; then
  #               sops --encrypt --in-place "{{.ITEM}}"
  #         fi
    vars:
      SECRET_FILES:
        sh: find "{{.ANSIBLE_DIR}}" "{{.TERRAFORM_DIR}}" "{{.KUBERNETES_DIR}}" -type f -name "*.sops.*" ! -name "*.encrypted.bak" ! -name "*.checksum" -print
    preconditions:
      - test -f {{.SOPS_AGE_KEY_FILE}}
      - test -f {{.ROOT_DIR}}/.sops.yaml
      - which jq sops

  download-cert-manager-crds:
    desc: Download cert-manager CRDs for configured version
    cmds:
      - |
        VERSION="{{.CERT_MANAGER_VERSION}}"
        CRD_FILE="{{.KUBERNETES_DIR}}/core/cert-manager/manifests/cert-manager-crds.yaml"

        # Create directory if it doesn't exist
        mkdir -p "{{.KUBERNETES_DIR}}/core/cert-manager/manifests"

        # Check if file exists and get current version
        if [ -f "$CRD_FILE" ]; then
          CURRENT_VERSION=$(yq eval '.metadata.labels."app.kubernetes.io/version" | select(. != null)' "$CRD_FILE" | head -n1)

          if [ "$CURRENT_VERSION" = "$VERSION" ]; then
            echo "cert-manager CRDs version $VERSION already exists, skipping download"
            exit 0
          else
            echo "Current CRDs version: $CURRENT_VERSION"
            echo "Required version: $VERSION"
            echo "Updating cert-manager CRDs..."
          fi
        else
          echo "cert-manager CRDs file not found, downloading..."
        fi

        # Download CRDs for the specific version
        echo "Downloading cert-manager CRDs for version ${VERSION}..."
        curl -fsSL "https://github.com/cert-manager/cert-manager/releases/download/${VERSION}/cert-manager.crds.yaml" \
          -o "$CRD_FILE"

        echo "Downloaded cert-manager CRDs to kubernetes/core/cert-manager/cert-manager-crds.yaml"
    vars:
      CERT_MANAGER_VERSION:
        sh: yq eval '.cert_manager_chart_version' config.yaml
    preconditions:
      - test -f config.yaml
      - which curl
      - which yq
